#include "Export.h"
#include <sstream>
#include <iomanip>
#include <string>

// Helper function to convert enum to string
static std::string sf_EmitterTypeToString(EmitterType type)
{
	switch (type)
	{
		case POINT: return "POINT";
		case LINE: return "LINE";
		case CIRCLE: return "CIRCLE";
		case RECTANGLE: return "RECTANGLE";

		default: return "POINT";
	}
}

static std::string sf_ParticleTypeToString(ParticleType type)
{
	switch (type)
	{
		case CIRCULER: return "CIRCULER";
		case SQUARE: return "SQUARE";
		case TRIANGLE: return "TRIANGLE";
		case K_CHAR: return "K_CHAR";
		
		default: return "CIRCULER";
	}
}

// Helper function to format Color as initializer
static std::string sf_ColorToString(const Color& color)
{
	std::ostringstream oss;
	oss << "{ " << 
	(int)color.r << ", " << 
	(int)color.g << ", " << 
	(int)color.b << ", " << 
	(int)color.a << " }";

	return oss.str();
}

// Helper function to format Vector2 as initializer
static std::string sf_Vector2ToString(const Vector2& vec)
{
	std::ostringstream oss;
	oss << std::fixed << std::setprecision(2) << "{ " << vec.x << "f, " << vec.y << "f }";
	return oss.str();
}

void t_ParticleSaver::Export(ParticleSystem& system, const char* path)
{
	std::ofstream file(std::string(path) + ".h");
	std::string name = std::string(path).substr(std::string(path).find_last_of("/\\") + 1);

	if (!file.is_open())
		return;

	std::ostringstream constructor_params;
	constructor_params << std::fixed << std::setprecision(2);

	constructor_params << name << "::" << name << "()\n"
		<< "\t: max_particles(" << system.max_particles << "),\n"
		<< "\trng(std::random_device{}()),\n"
		<< "\tdist(0.0f, 1.0f),\n"
		<< "\tposition(" << sf_Vector2ToString(system.position) << "),\n"
		<< "\te_EmitterType(" << sf_EmitterTypeToString(system.e_EmitterType) << "),\n"
		<< "\te_ParticleType(" << sf_ParticleTypeToString(system.e_ParticleType) << "),\n"
		<< "\tparticle_texture({}),\n"
		<< "\tb_UseTexture(" << (system.b_UseTexture ? "true" : "false") << "),\n"
		<< "\temission_rate(" << system.emission_rate << "f),\n"
		<< "\temission_timer(0.0f),\n"
		<< "\tvelocity(" << sf_Vector2ToString(system.velocity) << "),\n"
		<< "\tvelocity_variation(" << sf_Vector2ToString(system.velocity_variation) << "),\n"
		<< "\tacceleration(" << sf_Vector2ToString(system.acceleration) << "),\n"
		<< "\tstart_color(" << sf_ColorToString(system.start_color) << "),\n"
		<< "\tend_color(" << sf_ColorToString(system.end_color) << "),\n"
		<< "\tmin_life(" << system.min_life << "f),\n"
		<< "\tmax_life(" << system.max_life << "f),\n"
		<< "\tmin_size(" << system.min_size << "f),\n"
		<< "\tmax_size(" << system.max_size << "f),\n"
		<< "\trotation_speed(" << system.rotation_speed << "f),\n"
		<< "\tline_length(" << system.line_length << "f),\n"
		<< "\tcircle_radius(" << system.circle_radius << "f),\n"
		<< "\trect_size(" << sf_Vector2ToString(system.rect_size) << "),\n"
		<< "\tb_Active(" << (system.b_Active ? "true" : "false") << "),\n"
		<< "\ttex_width(" << system.tex_width << "),\n"
		<< "\ttex_height(" << system.tex_height << "),\n"
		<< "\toriginal_tex_width(" << system.original_tex_width << "),\n"
		<< "\toriginal_tex_height(" << system.original_tex_height << "),\n"
		<< "\ttex_size_percent(" << system.tex_size_percent << "f),\n"
		<< "\tb_TextureDataCached(false)\n"
		<< "{\n"
		<< "\tparticles.reserve(max_particles);\n"
		<< "}\n";

	std::string particle_code =
		"#pragma once\n"
		"#include <raylib.h>\n"
		"#include <vector>\n"
		"#include <random>\n"
		"#include <raymath.h>\n"
		"\n"
		"struct t_Particle\n"
		"{\n"
		"\tVector2 position;\n"
		"\tVector2 velocity;\n"
		"\tVector2 acceleration;\n"
		"\tColor color;\n"
		"\tfloat life;\n"
		"\tfloat max_life;\n"
		"\tfloat size;\n"
		"\tfloat rotation;\n"
		"\tfloat rotation_speed;\n"
		"\tbool b_Active;\n"
		"};\n"
		"\n"
		"enum EmitterType\n"
		"{\n"
		"\tPOINT,\n"
		"\tLINE,\n"
		"\tCIRCLE,\n"
		"\tRECTANGLE\n"
		"};\n"
		"\n"
		"enum ParticleType\n"
		"{\n"
		"\tCIRCULER,\n"
		"\tSQUARE,\n"
		"\tTRIANGLE,\n"
		"\tK_CHAR\n"
		"};\n"
		"\n"
		"class " + name + "\n"
		"{\n"
		"protected:\n"
		"\tfriend class ParticleSaver;\n"
		"\tstd::vector<t_Particle> particles;\n"
		"\tstd::mt19937 rng;\n"
		"\tstd::uniform_real_distribution<float> dist;\n"
		"\n"
		"\t// Emitter properties\n"
		"\tEmitterType e_EmitterType;\n"
		"\tParticleType e_ParticleType;\n"
		"\tTexture2D particle_texture;\n"
		"\tbool b_UseTexture;\n"
		"\tfloat emission_rate;\n"
		"\tfloat emission_timer;\n"
		"\n"
		"\t// Particle properties\n"
		"\tVector2 velocity;\n"
		"\tVector2 velocity_variation;\n"
		"\tVector2 acceleration;\n"
		"\tColor start_color;\n"
		"\tColor end_color;\n"
		"\tfloat min_life;\n"
		"\tfloat max_life;\n"
		"\tfloat min_size;\n"
		"\tfloat max_size;\n"
		"\tfloat rotation_speed;\n"
		"\n"
		"\t// Emitter shape properties\n"
		"\tfloat line_length;\n"
		"\tfloat circle_radius;\n"
		"\tVector2 rect_size;\n"
		"\tbool b_Active;\n"
		"\tint max_particles;\n"
		"\n"
		"\t// For texture\n"
		"\tRectangle texture_source_rect;\n"
		"\tVector2 texture_half_size;\n"
		"\tVector2 texture_center;\n"
		"\tint tex_width;\n"
		"\tint tex_height;\n"
		"\tint new_width;\n"
		"\tint new_height;\n"
		"\tint original_tex_width;\n"
		"\tint original_tex_height;\n"
		"\tfloat tex_size_percent;\n"
		"\tbool b_TextureDataCached;\n"
		"\n"
		"\tVector2 GetEmissionPoint();\n"
		"\tvoid EmitParticle();\n"
		"\tvoid DrawEmitterShape() const;\n"
		"\tvoid Clear();\n"
		"\tint GetParticleCount() const;\n"
		"\n"
		"public:\n"
		"\tVector2 position;\n"
		"\n"
		"\t" + name + "(); \n"
		"\t~" + name + "(); \n"
		"\tvoid Update(float dt);\n"
		"\tvoid Draw();\n"
		"\n"
		"\t// Texture management\n"
		"\tbool b_LoadTexture(const char* filename);\n"
		"\tvoid UnloadTexture();\n"
		"\tvoid SetUseTexture(bool use);\n"
		"\tbool b_IsUsingTexture() const;\n"
		"};\n"
		"\n"
		"// Constructor with current system parameters\n"
		+ constructor_params.str() +
		"\n"
		+ name + "::~" + name + "()\n"
		"{\n"
		"\tUnloadTexture();\n"
		"}\n"
		"\n"
		"bool " + name + "::b_LoadTexture(const char* filename)\n"
		"{\n"
		"\t// Unload Previous texture\n"
		"\tUnloadTexture();\n"
		"\n"
		"\tImage img = LoadImage(filename);\n"
		"\toriginal_tex_width = img.width;\n"
		"\toriginal_tex_height = img.height;\n"
		"\n"
		"\tnew_width = static_cast<int>((original_tex_width * tex_size_percent) / 100);\n"
		"\tnew_height = static_cast<int>((original_tex_height * tex_size_percent) / 100);\n"
		"\n"
		"\tif (new_width > 0 && new_height > 0)\n"
		"\t{\n"
		"\t\tImageResize(&img, new_width, new_height);\n"
		"\t}\n"
		"\n"
		"\tparticle_texture = LoadTextureFromImage(img);\n"
		"\tUnloadImage(img);\n"
		"\tif (particle_texture.id > 0)\n"
		"\t{\n"
		"\t\tb_UseTexture = true;\n"
		"\t\ttexture_source_rect =\n"
		"\t\t{\n"
		"\t\t\t0, 0,\n"
		"\t\t\tstatic_cast<float>(particle_texture.width),\n"
		"\t\t\tstatic_cast<float>(particle_texture.height)\n"
		"\t\t};\n"
		"\n"
		"\t\ttexture_half_size =\n"
		"\t\t{\n"
		"\t\t\tstatic_cast<float>(particle_texture.width) * 0.5f,\n"
		"\t\t\tstatic_cast<float>(particle_texture.height) * 0.5f\n"
		"\t\t};\n"
		"\n"
		"\t\ttexture_center =\n"
		"\t\t{\n"
		"\t\t\ttexture_source_rect.x / 2,\n"
		"\t\t\ttexture_source_rect.y / 2\n"
		"\t\t};\n"
		"\n"
		"\t\tb_TextureDataCached = true;\n"
		"\t\tGenTextureMipmaps(&particle_texture);\n"
		"\t\tSetTextureFilter(particle_texture, TEXTURE_FILTER_TRILINEAR);\n"
		"\t\treturn true;\n"
		"\t}\n"
		"\n"
		"\tb_UseTexture = false;\n"
		"\tb_TextureDataCached = false;\n"
		"\treturn false;\n"
		"}\n"
		"\n"
		"void " + name + "::UnloadTexture()\n"
		"{\n"
		"\tif (particle_texture.id > 0)\n"
		"\t{\n"
		"\t\t::UnloadTexture(particle_texture);\n"
		"\t\tparticle_texture = {};\n"
		"\t}\n"
		"\tb_UseTexture = false;\n"
		"\tb_TextureDataCached = false;\n"
		"}\n"
		"\n"
		"void " + name + "::SetUseTexture(bool use)\n"
		"{\n"
		"\tb_UseTexture = use && (particle_texture.id > 0);\n"
		"}\n"
		"\n"
		"bool " + name + "::b_IsUsingTexture() const\n"
		"{\n"
		"\treturn b_UseTexture && (particle_texture.id > 0);\n"
		"}\n"
		"\n"
		"Vector2 " + name + "::GetEmissionPoint()\n"
		"{\n"
		"\tswitch (e_EmitterType)\n"
		"\t{\n"
		"\tcase POINT:\n"
		"\t\treturn position;\n"
		"\n"
		"\tcase LINE:\n"
		"\t{\n"
		"\t\tfloat t = dist(rng);\n"
		"\t\treturn\n"
		"\t\t{\n"
		"\t\t\tposition.x + (t - 0.5f) * line_length,\n"
		"\t\t\tposition.y\n"
		"\t\t};\n"
		"\t}\n"
		"\n"
		"\tcase CIRCLE:\n"
		"\t{\n"
		"\t\tfloat angle = (dist(rng) * 2.0f - 1.0f) * PI;\n"
		"\t\tfloat radius = dist(rng) * circle_radius;\n"
		"\t\treturn\n"
		"\t\t{\n"
		"\t\t\tposition.x + cosf(angle) * radius,\n"
		"\t\t\tposition.y + sinf(angle) * radius\n"
		"\t\t};\n"
		"\t}\n"
		"\n"
		"\tcase RECTANGLE:\n"
		"\t{\n"
		"\t\treturn\n"
		"\t\t{\n"
		"\t\t\tposition.x + (dist(rng) - 0.5f) * rect_size.x,\n"
		"\t\t\tposition.y + (dist(rng) - 0.5f) * rect_size.y\n"
		"\t\t};\n"
		"\t}\n"
		"\n"
		"\tdefault:\n"
		"\t\treturn position;\n"
		"\t}\n"
		"}\n"
		"\n"
		"void " + name + "::EmitParticle()\n"
		"{\n"
		"\tif (particles.size() >= max_particles)\n"
		"\t\treturn;\n"
		"\n"
		"\tt_Particle p;\n"
		"\tp.position = GetEmissionPoint();\n"
		"\tp.velocity =\n"
		"\t{\n"
		"\t\tvelocity.x + (dist(rng) - 0.5f) * velocity_variation.x,\n"
		"\t\tvelocity.y + (dist(rng) - 0.5f) * velocity_variation.y\n"
		"\t};\n"
		"\tp.acceleration = acceleration;\n"
		"\tp.color = start_color;\n"
		"\tp.life = p.max_life = min_life + dist(rng) * (max_life - min_life);\n"
		"\tp.size = min_size + dist(rng) * (max_size - min_size);\n"
		"\tp.rotation = 0;\n"
		"\tp.rotation_speed = rotation_speed + (dist(rng) - 0.5f) * 2.0f;\n"
		"\tp.b_Active = true;\n"
		"\tparticles.push_back(p);\n"
		"}\n"
		"\n"
		"void " + name + "::Update(float dt)\n"
		"{\n"
		"\tif (!b_Active)\n"
		"\t\treturn;\n"
		"\n"
		"\t// Emit new particles\n"
		"\temission_timer += dt;\n"
		"\tconst float EMISSION_INTERVAL = 1.0f / emission_rate;\n"
		"\twhile (emission_timer >= EMISSION_INTERVAL)\n"
		"\t{\n"
		"\t\tEmitParticle();\n"
		"\t\temission_timer -= EMISSION_INTERVAL;\n"
		"\t}\n"
		"\n"
		"\tbool b_ColorTransition =\n"
		"\t\tstart_color.r != end_color.r ||\n"
		"\t\tstart_color.g != end_color.g ||\n"
		"\t\tstart_color.b != end_color.b;\n"
		"\n"
		"\t// Update existing particles\n"
		"\tfor (size_t i = 0; i < particles.size();)\n"
		"\t{\n"
		"\t\tt_Particle& p = particles[i];\n"
		"\t\tif (!p.b_Active || p.life <= 0)\n"
		"\t\t{\n"
		"\t\t\t// Added optimization\n"
		"\t\t\tstd::swap(particles[i], particles.back());\n"
		"\t\t\tparticles.pop_back();\n"
		"\t\t\tcontinue;\n"
		"\t\t}\n"
		"\n"
		"\t\t// Physics update\n"
		"\t\tp.velocity.x += p.acceleration.x * dt;\n"
		"\t\tp.velocity.y += p.acceleration.y * dt;\n"
		"\t\tp.position.x += p.velocity.x * dt;\n"
		"\t\tp.position.y += p.velocity.y * dt;\n"
		"\t\tp.rotation += p.rotation_speed * dt;\n"
		"\t\tp.life -= dt;\n"
		"\n"
		"\t\t// Color fade\n"
		"\t\tfloat life_ratio = p.life / p.max_life;\n"
		"\t\tfloat t = 1.0f - life_ratio;\n"
		"\n"
		"\t\tif (b_ColorTransition)\n"
		"\t\t{\n"
		"\t\t\tp.color.r = Clamp(start_color.r * (1.0f - t) + end_color.r * t, 0, 255);\n"
		"\t\t\tp.color.g = Clamp(start_color.g * (1.0f - t) + end_color.g * t, 0, 255);\n"
		"\t\t\tp.color.b = Clamp(start_color.b * (1.0f - t) + end_color.b * t, 0, 255);\n"
		"\t\t}\n"
		"\n"
		"\t\tp.color.a = Clamp(255.0f * life_ratio, 0, 255);\n"
		"\t\t++i;\n"
		"\t}\n"
		"}\n"
		"\n"
		"void " + name + "::DrawEmitterShape() const\n"
		"{\n"
		"\tColor shape_color = { 128, 128, 128, 100 };\n"
		"\n"
		"\tswitch (e_EmitterType)\n"
		"\t{\n"
		"\tcase POINT:\n"
		"\t\tDrawCircleV(position, 3, shape_color);\n"
		"\t\tbreak;\n"
		"\n"
		"\tcase LINE:\n"
		"\t\tDrawLineEx\n"
		"\t\t(\n"
		"\t\t\t{ position.x - line_length / 2, position.y },\n"
		"\t\t\t{ position.x + line_length / 2, position.y },\n"
		"\t\t\t2, shape_color\n"
		"\t\t);\n"
		"\t\tbreak;\n"
		"\n"
		"\tcase CIRCLE:\n"
		"\t\tDrawCircleLinesV(position, circle_radius, shape_color);\n"
		"\t\tbreak;\n"
		"\n"
		"\tcase RECTANGLE:\n"
		"\t\tDrawRectangleLinesEx\n"
		"\t\t(\n"
		"\t\t\t{\n"
		"\t\t\t\tposition.x - rect_size.x / 2,\n"
		"\t\t\t\tposition.y - rect_size.y / 2,\n"
		"\t\t\t\trect_size.x, rect_size.y\n"
		"\t\t\t},\n"
		"\t\t\t2, shape_color\n"
		"\t\t);\n"
		"\t\tbreak;\n"
		"\t}\n"
		"}\n"
		"\n"
		"void " + name + "::Draw()\n"
		"{\n"
		"\tbool b_UseTex = b_IsUsingTexture() && b_TextureDataCached;\n"
		"\n"
		"\tfor (const auto& p : particles)\n"
		"\t{\n"
		"\t\tif (!p.b_Active)\n"
		"\t\t\tcontinue;\n"
		"\n"
		"\t\t// If using texture, draw texture instead of geometric shapes\n"
		"\t\tif (b_UseTex)\n"
		"\t\t{\n"
		"\t\t\tRectangle dest =\n"
		"\t\t\t{\n"
		"\t\t\t\tp.position.x - texture_center.x,\n"
		"\t\t\t\tp.position.y - texture_center.y,\n"
		"\t\t\t\ttexture_source_rect.width,\n"
		"\t\t\t\ttexture_source_rect.height\n"
		"\t\t\t};\n"
		"\n"
		"\t\t\tDrawTexturePro\n"
		"\t\t\t(\n"
		"\t\t\t\tparticle_texture,\n"
		"\t\t\t\ttexture_source_rect,\n"
		"\t\t\t\tdest,\n"
		"\t\t\t\ttexture_half_size,\n"
		"\t\t\t\tp.rotation * RAD2DEG,\n"
		"\t\t\t\tWHITE\n"
		"\t\t\t);\n"
		"\t\t}\n"
		"\t\telse\n"
		"\t\t{\n"
		"\t\t\t// Draw geometric shapes \n"
		"\t\t\tswitch (e_ParticleType)\n"
		"\t\t\t{\n"
		"\t\t\tcase CIRCULER:\n"
		"\t\t\t{\n"
		"\t\t\t\tDrawCircleV(p.position, p.size, p.color);\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\n"
		"\t\t\tcase SQUARE:\n"
		"\t\t\t{\n"
		"\t\t\t\tRectangle rect =\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tp.position.x - p.size / 2,\n"
		"\t\t\t\t\tp.position.y - p.size / 2,\n"
		"\t\t\t\t\tp.size,\n"
		"\t\t\t\t\tp.size\n"
		"\t\t\t\t};\n"
		"\n"
		"\t\t\t\tDrawRectanglePro\n"
		"\t\t\t\t(\n"
		"\t\t\t\t\trect,\n"
		"\t\t\t\t\t{ p.size / 2, p.size / 2 },\n"
		"\t\t\t\t\tp.rotation * RAD2DEG,\n"
		"\t\t\t\t\tp.color\n"
		"\t\t\t\t);\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\n"
		"\t\t\tcase TRIANGLE:\n"
		"\t\t\t{\n"
		"\t\t\t\tDrawPoly\n"
		"\t\t\t\t(\n"
		"\t\t\t\t\tp.position,\n"
		"\t\t\t\t\t3,\n"
		"\t\t\t\t\tp.size,\n"
		"\t\t\t\t\tp.rotation * RAD2DEG,\n"
		"\t\t\t\t\tp.color\n"
		"\t\t\t\t);\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\n"
		"\t\t\tcase K_CHAR:\n"
		"\t\t\t{\n"
		"\t\t\t\tVector2 vertices[6] =\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\t{-p.size / 2, p.size / 2},\t// Top-left (vertical line top)\n"
		"\t\t\t\t\t{-p.size / 2, -p.size / 2}, // Bottom-left (vertical line bottom)\n"
		"\t\t\t\t\t{-p.size / 2, 0},\t\t\t// Middle-left (center junction)\n"
		"\t\t\t\t\t{p.size / 2, p.size / 2},\t// Top-right (upper diagonal end)\n"
		"\t\t\t\t\t{p.size / 2, -p.size / 2},\t// Bottom-right (lower diagonal end)\n"
		"\t\t\t\t\t{-p.size / 2, 0}\t\t\t// Middle-left (center junction - repeated for connection)\n"
		"\t\t\t\t};\n"
		"\n"
		"\t\t\t\t// Define the lines that make up the K shape\n"
		"\t\t\t\tint lines[][2] =\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\t{0, 1}, // Vertical line (left side)\n"
		"\t\t\t\t\t{2, 3}, // Upper diagonal\n"
		"\t\t\t\t\t{2, 4}\t// Lower diagonal\n"
		"\t\t\t\t};\n"
		"\n"
		"\t\t\t\t// Draw each line of the K\n"
		"\t\t\t\tfor (int i = 0; i < 3; ++i)\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tVector2& v1 = vertices[lines[i][0]];\n"
		"\t\t\t\t\tVector2& v2 = vertices[lines[i][1]];\n"
		"\n"
		"\t\t\t\t\t// Apply rotation transformation\n"
		"\t\t\t\t\tVector2 a =\n"
		"\t\t\t\t\t{\n"
		"\t\t\t\t\t\tp.position.x + v1.x * cosf(p.rotation) - v1.y * sinf(p.rotation),\n"
		"\t\t\t\t\t\tp.position.y + v1.x * sinf(p.rotation) + v1.y * cosf(p.rotation)\n"
		"\t\t\t\t\t};\n"
		"\t\t\t\t\tVector2 b =\n"
		"\t\t\t\t\t{\n"
		"\t\t\t\t\t\tp.position.x + v2.x * cosf(p.rotation) - v2.y * sinf(p.rotation),\n"
		"\t\t\t\t\t\tp.position.y + v2.x * sinf(p.rotation) + v2.y * cosf(p.rotation)\n"
		"\t\t\t\t\t};\n"
		"\n"
		"\t\t\t\t\tDrawLineEx(a, b, 2, p.color);\n"
		"\t\t\t\t}\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tEndScissorMode();\n"
		"}\n"
		"\n"
		"void " + name + "::Clear()\n"
		"{\n"
		"\tparticles.clear();\n"
		"}\n"
		"\n"
		"int " + name + "::GetParticleCount() const\n"
		"{\n"
		"\treturn particles.size();\n"
		"}\n";

	file << particle_code;
	file.close();
}